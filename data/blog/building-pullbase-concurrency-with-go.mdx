---
title: "Building Pull Base: Elegant Concurrency with Go's Context System"
draft: false
date: '2025-05-12'
summary: "Let's examine how PullBase implements context-based concurrency management in its GitMonitor component, and how this pattern can be applied to your own Go applications."
tags: ['Go', 'Concurrency']
---

Go's concurrency model is a key reason many developers choose the language for systems programming. In Pull Base, I've leveraged Go's context package extensively to create a robust concurrency pattern for our long-running operations. This approach ensures our application can gracefully handle shutdowns, timeouts, and cancellations.

Let's examine how [Pull Base](https://pullbase.io) implements context-based concurrency management in its `GitMonitor` component, and how this pattern, aligned with standard library practices, can be applied to your own Go applications.

## The Problem: Managing Long-Running Operations

When building server applications, you'll often need background processes that run continuously. Consider these challenges:

- How do you cleanly shut down these processes when the application stops?
- How do you prevent resource leaks during abnormal termination?
- How do you coordinate the cancellation of multiple related operations?
- How do you prevent long-running tasks from blocking indefinitely?

Traditional solutions like global variables and boolean flags quickly become unwieldy. Go's context package provides a more elegant solution, and we've implemented it systematically throughout Pull Base.

## The Context-Driven Design Pattern

In the core of Pull Base, the `GitMonitor` component exemplifies an effective pattern for managing background tasks. It watches multiple Git repositories, periodically checking for changes and updating server states.

Instead of storing a context within the `Monitor` struct for its entire lifetime (which is generally discouraged), we manage context lifecycle explicitly during the start and stop phases:

```go
// Monitor handles cloning/pulling Git repositories and updating target commit hashes.
type Monitor struct {
	db           *sqlx.DB
	repo         database.GitMonitorRepository
	pollInterval time.Duration
	clonePath    string
	mu           sync.RWMutex
	serverRepos  map[string]*git.Repository
	mainCancel   context.CancelFunc // Function to cancel the main context used by the polling loop
	repoLocks    map[string]*sync.Mutex // Per-repository locks for concurrent checks
}

// NewMonitor creates a new GitMonitor.
func NewMonitor(db *sqlx.DB, repo database.GitMonitorRepository, pollInterval time.Duration, clonePath string) (*Monitor, error) {

	return &Monitor{
		db:           db,
		repo:         repo,
		pollInterval: pollInterval,
		clonePath:    clonePath,
		serverRepos:  make(map[string]*git.Repository),
		repoLocks:    make(map[string]*sync.Mutex),
		// mainCancel is intentionally nil until Start() is called
	}, nil
}
```

The `Monitor` struct includes:
- A `mainCancel` field of type `context.CancelFunc`. This field is populated by `Start()` and used by `Stop()` to signal the main polling goroutine to terminate. It is protected by a mutex (`mu`) to prevent race conditions during start/stop operations.
- Per-repository state (`serverRepos` and `repoLocks`) also protected by the mutex.

## Starting and Stopping the Monitor

The `Start` method is responsible for setting up the context for the background polling loop and launching it.

```go
// Start initializes the monitor and begins the polling loop.
func (m *Monitor) Start() error {
	if m.repo == nil {
		return fmt.Errorf("monitor repository is not initialized")
	}
	m.mu.Lock()
	if m.mainCancel != nil {
		m.mu.Unlock()
		return fmt.Errorf("monitor already started")
	}

	// Create a new cancellable context for this run.
	ctx, cancel := context.WithCancel(context.Background())
	// Store the cancel function for later use by Stop().
	m.mainCancel = cancel
	m.mu.Unlock() // Unlock before potentially long-running loadAllServers

	log.Println("Git monitor starting...")

	// Perform initial server loading; pass the newly created context.
	if err := m.loadAllServers(ctx); err != nil {
		// Handle potential cancellation during startup
		if ctx.Err() != nil {
			log.Printf("Git monitor startup cancelled during initial server load: %v", ctx.Err())
			// Clean up the cancel function if startup failed due to cancellation
			m.mu.Lock()
			if m.mainCancel != nil {
				m.mainCancel()
				m.mainCancel = nil
			}
			m.mu.Unlock()
			return fmt.Errorf("failed to load initial servers due to cancellation: %w", err)
		}
		// Log non-cancellation errors but continue startup
		log.Printf("Warning: Failed to load initial servers: %v", err)
	}

	// Launch the polling loop in a separate goroutine, passing the context.
	go m.runPollingLoop(ctx)

	log.Println("Git monitor started successfully.")
	return nil
}
```

The `Stop` method simply calls the stored `mainCancel` function:

```go
// Stop signals the monitor to stop polling.
func (m *Monitor) Stop() {
	log.Println("Stopping Git monitor...")
	m.mu.Lock()
	defer m.mu.Unlock()

	// If mainCancel exists, call it to signal the context is Done.
	if m.mainCancel != nil {
		m.mainCancel()
		// Set to nil to indicate the monitor is stopped and allow restarting.
		m.mainCancel = nil
	}
	log.Println("Git monitor stop signal sent.")
}
```

This pattern ensures:
- The context's lifecycle is tied to the monitor's started/stopped state.
- The `mainCancel` function acts as the primary signal for graceful shutdown of the polling loop.
- Proper locking prevents race conditions if `Start` or `Stop` are called concurrently.

## The Polling Loop Pattern

The heart of our `GitMonitor` is the `runPollingLoop`. It uses the context passed from `Start` for cancellation and employs a `time.Timer` for periodic checks. Using a timer instead of a ticker prevents work from piling up if a check cycle takes longer than the polling interval.

```go
// runPollingLoop periodically checks all registered Git repositories.
// It accepts the main context for cancellation.
func (m *Monitor) runPollingLoop(ctx context.Context) {
	log.Printf("Starting Git polling loop with interval: %v", m.pollInterval)

	// Perform an initial check immediately after starting.
	log.Println("Performing initial repository check...")
	// Check if context is already cancelled before the first check.
	if ctx.Err() == nil {
		if err := m.checkAllRepositories(ctx); err != nil {
			log.Printf("Error during initial repository check: %v", err)
		}
	} else {
		log.Printf("Monitor context cancelled before initial repository check.")
		return // Exit if cancelled before starting the loop.
	}

	// Initialize a timer for the polling interval.
	timer := time.NewTimer(m.pollInterval)
	// Ensure the timer is stopped when the function exits (e.g., on context cancellation).
	defer timer.Stop()

	for {
		select {
		case <-ctx.Done(): // Listen for cancellation signal from the main context.
			log.Println("Monitor context cancelled, stopping poll loop.")
			return // Exit the goroutine.
		case <-timer.C: // Wait for the timer to fire.
			log.Println("Polling repositories...")
			// Pass the main context down to the checking function.
			if err := m.checkAllRepositories(ctx); err != nil {
				log.Printf("Error checking repositories: %v", err)
				// Note: Non-fatal errors don't stop the loop.
			}
			// Reset the timer for the next interval after the check completes.
			// This ensures checks don't queue up if they take longer than the interval.
			timer.Reset(m.pollInterval)
		}
	}
}
```

This pattern provides several key benefits:
- The loop automatically terminates when the `ctx` passed from `Start` is cancelled via `Stop`.
- Resources (the timer) are properly cleaned up via `defer`.
- Using `timer.Reset` ensures consistent polling frequency without overlap.
- The code clearly communicates both the timer-driven and cancellation behaviors.

## Graceful Shutdown Handling

When the application receives a termination signal (like SIGINT or SIGTERM), we implement clean shutdown logic in `main.go`.

```go
// In main.go
stopChan := make(chan os.Signal, 1)
signal.Notify(stopChan, syscall.SIGINT, syscall.SIGTERM)

go func() {
	log.Printf("INFO: HTTPS Server starting on %s", serverAddr)
	if err := httpServer.ListenAndServeTLS(certFile, keyFile); err != nil && err != http.ErrServerClosed {
		log.Fatalf("FATAL: Could not listen on %s: %v\n", serverAddr, err)
	}
}()

// Wait for interrupt signal
<-stopChan
log.Println("INFO: Shutting down server...")

// Setup graceful shutdown context with a timeout for the HTTP server.
shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 5*time.Second)
defer shutdownCancel()

if err := httpServer.Shutdown(shutdownCtx); err != nil {
	log.Printf("WARN: Server shutdown failed: %v", err)
}

// Stop Git monitor if enabled by calling its Stop method.
if cfg.Git.Enabled && gitMonitor != nil {
	gitMonitor.Stop() // This calls mainCancel inside the monitor.
	// Note: We might want to wait briefly here or have Stop() be blocking
	// if we need to ensure the polling loop fully exits before main returns.
}

log.Println("INFO: Server gracefully stopped")
```

This ensures that when the user presses Ctrl+C or when the service is stopped, the `gitMonitor.Stop()` method is called, triggering the cancellation of the polling loop's context and allowing for a clean exit.

## Context Propagation and Bounded Concurrency

The context created in `Start` is passed down through `runPollingLoop` to `checkAllRepositories`. Inside `checkAllRepositories`, we use an `errgroup.Group` with a concurrency limit to manage checking multiple repositories efficiently without overwhelming system resources. The group's context (`gCtx`) is derived from the main context, ensuring that if the main context is cancelled, all ongoing checks within the group are also notified.

```go
// checkAllRepositories iterates through all monitored servers and checks their repositories.
func (m *Monitor) checkAllRepositories(ctx context.Context) error {
	m.mu.RLock() // Read lock to safely copy repo info
	serverCount := len(m.serverRepos)
	serverNames := make([]string, 0, serverCount)
	reposToProcess := make([]*git.Repository, 0, serverCount)
	locksToUse := make([]*sync.Mutex, 0, serverCount)
	for name, repo := range m.serverRepos {
		lock, ok := m.repoLocks[name]
		if !ok {
			log.Printf("Warning: Lock for server %s not found during checkAllRepositories setup. Skipping.", name)
			continue
		}
		serverNames = append(serverNames, name)
		reposToProcess = append(reposToProcess, repo)
		locksToUse = append(locksToUse, lock)
	}
	m.mu.RUnlock() // Release lock before starting concurrent work

	if len(serverNames) == 0 {
		log.Println("No servers available or locks found for repository checking.")
		return nil
	}

	// Create an errgroup with the parent context.
	g, gCtx := errgroup.WithContext(ctx)
	// Limit concurrency to the number of CPU cores.
	limit := runtime.NumCPU()
	if limit < 1 {
		limit = 1
	}
	g.SetLimit(limit)

	// Launch a goroutine for each repository check within the errgroup.
	for i, currentName := range serverNames {
		// Capture loop variables correctly for the goroutine.
		name := currentName
		repo := reposToProcess[i]
		repoLock := locksToUse[i]

		g.Go(func() error {
			// Check if the group's context is cancelled before starting work.
			select {
			case <-gCtx.Done():
				log.Printf("Skipping check for %s due to group context cancellation: %v", name, gCtx.Err())
				return gCtx.Err() // Return context error to the group.
			default:
			}

			// Acquire the specific lock for this repository.
			repoLock.Lock()
			defer repoLock.Unlock()

			// Pass the group's context down to the individual check function.
			// This allows checkRepository to also react to cancellation.
			if err := m.checkRepository(gCtx, name, repo); err != nil {
				log.Printf("Error detail in errgroup worker for %s: %v", name, err)
				// Return a wrapped error to the errgroup.
				return fmt.Errorf("server %s check failed: %w", name, err)
			}
			return nil // Success for this worker.
		})
	}

	// Wait for all goroutines in the group to complete and collect the first error.
	if err := g.Wait(); err != nil {
		// Log cancellation/timeout specifically.
		if errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) {
			log.Printf("checkAllRepositories cancelled or timed out: %v", err)
		} else {
			log.Printf("checkAllRepositories completed with errors: %v", err)
		}
		// Propagate the error.
		return fmt.Errorf("one or more repository checks failed during checkAllRepositories: %w", err)
	}

	log.Println("Finished checking all repositories successfully.")
	return nil
}
```

This demonstrates how context is propagated and used effectively with `errgroup` for controlled, cancellable concurrency.

## Timeouts for Specific Operations

While the main polling loop uses context primarily for cancellation signals, Pull Base uses `context.WithTimeout` for specific, potentially long-running operations like Git commands. This prevents individual operations from hanging indefinitely.

```go
func (m *Monitor) checkRepository(ctx context.Context, serverName string, repo *git.Repository) error {
	// ... (initial context check) ...

	log.Printf("Fetching remote for %s...", serverName)
	fetchOpts := &git.FetchOptions{ /* ... options ... */ }

	// Create a derived context with a specific timeout for the Git fetch operation.
	fetchCtx, cancel := context.WithTimeout(ctx, gitOperationTimeout)
	defer cancel() // IMPORTANT: Always call cancel for timeout contexts.

	// Perform the fetch using the derived context.
	err := repo.FetchContext(fetchCtx, fetchOpts)

	if err != nil && err != git.NoErrAlreadyUpToDate {
		// Check specifically if the timeout was exceeded.
		if fetchCtx.Err() == context.DeadlineExceeded {
			return fmt.Errorf("failed to fetch remote for %s: operation timed out after %v: %w", serverName, gitOperationTimeout, err)
		}
		// Check if the parent context (passed into checkRepository) was cancelled.
		select {
		case <-ctx.Done():
			log.Printf("Fetch cancelled for %s by parent context: %v", serverName, ctx.Err())
			return ctx.Err() // Propagate parent cancellation.
		default:
			// Handle other Git fetch errors.
			return fmt.Errorf("failed to fetch remote for %s: %w", serverName, err)
		}
	}
	// ... (rest of the check logic, also checking ctx.Done() periodically) ...
	return nil
}
```
This selective use of timeouts adds resilience against external dependencies like the network or Git operations, while the main context handles the overall lifecycle cancellation.

## Practical Implementation Tips

From my experience building Pull Base, here are some best practices for context-based concurrency:

- **Explicit Lifecycle Management**: Use dedicated `Start` and `Stop` methods to manage the context and cancellation function (`mainCancel`) for long-running components like `GitMonitor`. Avoid storing contexts directly in structs for the component's lifetime.
- **Context Propagation**: Pass context explicitly down the call stack. Functions receiving a context should respect its cancellation signal (`ctx.Done()`).
- **Graceful Shutdown Signal**: Use the `context.CancelFunc` obtained from `context.WithCancel` as the primary mechanism to signal shutdown to the main loop of a background process.
- **Operation Timeouts**: Apply `context.WithTimeout` to specific, potentially blocking operations (I/O, network calls, external processes) to prevent them from hanging indefinitely. Always `defer cancel()` for these timeout contexts.
- **Bounded Concurrency**: Utilize tools like `errgroup.Group` with `SetLimit` to control the number of concurrent goroutines performing similar tasks, preventing resource exhaustion. Pass the group's derived context (`gCtx`) to worker goroutines.
- **Mutex for Shared State**: Protect access to shared data structures (like `serverRepos` and `repoLocks`) with appropriate mutexes (`sync.RWMutex` or `sync.Mutex`). Keep critical sections short. For operations involving concurrency *and* shared state (like `checkAllRepositories`), acquire locks carefully (e.g., use read locks to copy data needed by workers, and specific locks within workers if they modify shared state).

## Conclusion

PullBase's concurrency model demonstrates how Go's context package enables clean, maintainable patterns for managing complex concurrent operations. By implementing context-based cancellation and timeouts systematically, we've created a resilient application that can gracefully handle shutdowns, properly manage resources like timers and goroutines, and remain responsive even when dealing with potentially slow external operations.

The next time you build a Go application with long-running processes or concurrent tasks, consider adopting this pattern of explicit context lifecycle management, propagation, and selective timeouts to make your concurrent code more robust and maintainable.